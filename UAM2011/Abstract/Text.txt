The angular resolution and contrast in active sonar images depends on physical properties of the aperture array being used, and on the beamformers ability to achieve spatial focus in the directions where we wish to derive the acoustic reflectivity, while suppressing noise and interference emanating from other directions. This is achieved by applying (potentially complex) weights to the array channels. The fundamental challenge, however, is to find the optimum set of weights, particularly since the data is not stationary. While classical beamformers selects windows that are optimal in various scenarios, adaptive beamformers estimate the optimal set of weights by analytical evaluation of the data. The minimum variance (MV) beamformer, for instance, calculates the set of weights that minimises variance across channels. To do so the spatial covariance matrix (R) must be estimated and inverted, typically translating to a computational complexity in the order of O(L^3), where L is the number of channels. Furthermore, subarray averaging and diagonal loading is introduced to deal with signal cancellation, and to ensure that R is invertible. To circumvent this, the optimisation criteria may be used to select one out of a set of predefined windows. In this case the computational complexity is in the order of O(W*L), where W is the number of pre-defined windows. This mitigates the need for estimating R in the first place, hence does not require subarray averaging, and the full array length can be used in the calculation. We will show that if the windows are selected wisely, the angular resolution will be on-par with, and in some cases even exceeding that of the MV beamformer. From the study of several adaptive methods, we will also derive a set of "optimal" windows, which should allow the method to adapt to a wide range of scenarios. Another advantage of such an algorithm is that it maps well to single-instruction-multiple-data SIMD hardware such as graphics processing units (GPUs). We will show that even a modest amount of optimisation work will result in a factor 10 speed-up of this algorithm when implemented on a GPU as opposed to on a CPU.